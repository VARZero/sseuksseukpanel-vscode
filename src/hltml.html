<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
:root{
    --backgroundC: /*var(--vscode-panel-background)*/ white;
    --elementC: /*var(--vscode-editor-foreground)*/ black;
}
body{
    user-select: none;
}
section#sys{
    display: none;
}
#EditBox{
    background-color: var(--backgroundC);
    display: flex;
    flex-direction: row;
    font-family: Consolas, monospace;
    font-size: 18px;
    height: 5em; width: 100%;
    border-bottom: 1px solid var(--elementC);
}

#textArea{
    color: var(--elementC);
    display: flex;
    border-right: 1px dotted var(--elementC);
}
.textChar{
    white-space: pre;
}
#textArea.active .textChar:hover{
    background-color: var(--elementC);
    color: var(--backgroundC);
}
.textChar.select{
    background-color: var(--elementC);
    color: var(--backgroundC);
}

#insertArea{
    height: 3.5em;
    display: flex;
}
.insertChar{
    position: relative;
    white-space: pre;
    color: var(--backgroundC);
}
.insertChar.active{
    border-left: 1px dashed var(--elementC);
}
#EditBox.NonActive .insertChar:hover{
    border-left: 1px dashed var(--elementC);
}

#appendArea{
    flex: 1;
    display: flex;
    flex-direction: row;
    height: 3.5em;
}
.appendEle{
    position: relative;
    white-space: pre;
}
.appendEle.active{
    border-left: 1px dashed var(--elementC);
}
#EditBox.NonActive .appendEle:hover{
    border-left: 1px dashed var(--elementC);
}
#appendTab{
    flex: 1;
}

#toolArea{
    font-weight: bolder;
    width: 100%; height: 24px;
    display: flex;
}

#loading{
    margin-right: 4px;
    opacity: 0;
}

#loading.active{
    opacity: 1;
}

#SelToolBox{
    display: none;
}

#SelToolBox.active{
    display: flex;
}

#InsToolBox{
    display: none;
}

#InsToolBox.active{
    display: flex;
}

.tools{
    color: var(--backgroundC);
    background-color: var(--elementC);
    margin-right: 4px;
    padding-left: 1em;
    padding-right: 1em;
    border: 1px solid ;
}

canvas{
    touch-action: none;
    left: 0;
    position: absolute;
    width: 80vw; height: 100%;
    z-index: 999;
    border-left: 1px dashed var(--elementC);
    border-top: 1px solid var(--elementC);
}

#ref{display: none;}
    </style>
    <title>SseukSsuek Panel</title>
</head>
<body>
    <section id="sys">
        <div id="toolArea">
            <div id="loading">
                <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><style>.spinner_P7sC{fill:var(--elementC);transform-origin:center;animation:spinner_svv2 .75s infinite linear}@keyframes spinner_svv2{100%{transform:rotate(360deg)}}</style><path d="M10.14,1.16a11,11,0,0,0-9,8.92A1.59,1.59,0,0,0,2.46,12,1.52,1.52,0,0,0,4.11,10.7a8,8,0,0,1,6.66-6.61A1.42,1.42,0,0,0,12,2.69h0A1.57,1.57,0,0,0,10.14,1.16Z" class="spinner_P7sC"/></svg>
            </div>
            <div id="SelToolBox">
                <div class="tools" id="cancel" onpointerdown="reload()">취소</div>
                <div class="tools" id="cut">자르기</div>
                <div class="tools" id="copy">복사</div>
                <div class="tools" id="delete">지우기</div>
            </div>
            <div id="InsToolBox">
                <div class="tools" id="stop" onpointerdown="reload()">중단</div>
                <div class="tools" id="space">공백</div>
                <div class="tools" id="tab">탭</div>
            </div>
        </div>
        <div id="EditBox" class="NonActive">
            <div id="strings">
                <div id="textArea" class="active">
                    <div class="textChar" id="ref"></div>
                </div>
                <div id="insertArea">
                    <div class="insertChar" id="ref"></div>
                </div>
            </div>
            <div id="appendArea">
                <div id="appendBehind" class="appendEle"> </div>
                <div id="appendSpace" class="appendEle">   </div>
                <div id="appendTab" class="appendEle"></div>
            </div>
        </div>
    </section>
    <section id="output">
    </section>
    <script>
let txt = "te xts"
let nowStatus = undefined;
const RefTa = document.querySelector("#sys > #toolArea");
const RefEb = document.querySelector("#sys > #EditBox");

class status{
    constructor(EB){
        this.targetEB = EB;

        this.drawActive = false;
        this.ctx = undefined;
        this.lastPointX = -1;
        this.lastPointY = -1;

        this.lineNum = -1;
        this.col = -1;

        this.select = 0; // 0: 선택 안함, 1: 하나만 선택, 2. 선택 완료
        this.selectStart = -1;
        this.selectEnd = -1;
        
        this.insert = false;
        this.insertStart = -1;

        this.append = false;

        this.nowCanv = undefined;
        this.setLastTime = undefined;
    }

    activeEB(type, target){
        let textA = this.targetEB.children[0].children[0];
        for (let insEle of this.targetEB.children[0].children[1].children){
            insEle.removeEventListener("pointerdown", insertPD);
        }
        let appendA = this.targetEB.children[1];
        appendA.children[0].removeEventListener("pointerdown", appbPD); // Behind
        appendA.children[1].removeEventListener("pointerdown", appsPD); // Space
        appendA.children[2].removeEventListener("pointerdown", apptPD); // Tab
        
        this.targetEB.classList.remove("NonActive");

        if (type == "select"){
            document.querySelector("#output #SelToolBox").classList.add("active");
        
            switch(this.select){
                case 0:
                    this.select = 1;
                    this.selectStart = Number(target.id.replace(/[^0-9]/g, ""));
                    target.classList.add("select");
                break;
                case 1:
                    this.select = 2;
                    this.selectEnd = Number(target.id.replace(/[^0-9]/g, ""));
                    for (let selEle of this.targetEB.children[0].children[0].children){
                        selEle.removeEventListener("pointerdown", insertPD);
                    }
                    for (let col = this.selectStart + 1; col <= this.selectEnd; col+=1){
                        document.querySelector("#output .textChar#t"+String(col)).classList.add("select");
                    }
                    textA.classList.remove("active");
                break;
            }
            return;
        }

        textA.classList.remove("active");
        switch(type){
            case "insert":
                this.insert = true;
                this.insertStart = Number(target.id.replace(/[^0-9]/g, ""));
            break;
            case "append":
                this.append = true;
            break;
        }
        document.querySelector("#output #InsToolBox").classList.add("active");
        
        let newCanv = document.createElement("canvas");
        target.appendChild(newCanv);
        newCanv.addEventListener("pointerdown", canvPD);

        newCanv.width = newCanv.offsetWidth;
        newCanv.height = newCanv.offsetHeight;
    }
}

function setSsuekSsuek(text){
    if (nowStatus != undefined){delete nowStatus;}
    document.getElementById("output").innerHTML = "";
    
    // Tool박스 이벤트 지정.
    newTa = RefTa.cloneNode(true);
    document.querySelector("#output").appendChild(newTa);

    newEb = RefEb.cloneNode(true);
    newEbTa = newEb.children[0].children[0]; newEbTc = newEbTa.children[0];
    newEbIa = newEb.children[0].children[1]; newEbIc = newEbIa.children[0];
    newEbAa = newEb.children[1];
    newEbAb = newEbAa.children[0]; newEbAs = newEbAa.children[1];newEbAt = newEbAa.children[2];
    document.querySelector("#output").appendChild(newEb);

    charnum = 0
    for (char of text){
        eEbTc = newEbTc.cloneNode(true); 
        eEbTc.id = "t" + charnum; eEbTc.innerText = char;
        eEbTc.addEventListener("pointerdown", selectPD);
        newEbTa.appendChild(eEbTc);
        eEbIc = newEbIc.cloneNode(true);
        eEbIc.id = "i" + charnum; eEbIc.innerText = char;
        eEbIc.addEventListener("pointerdown", insertPD);
        newEbIa.appendChild(eEbIc);
        charnum += 1;
    }
    newEbAb.addEventListener("pointerdown", appbPD);
    newEbAs.addEventListener("pointerdown", appsPD);
    newEbAt.addEventListener("pointerdown", apptPD);
    nowStatus = new status(newEb);
}

function selectPD(e){
    nowStatus.activeEB("select", e.currentTarget);
}

function insertPD(e){
    nowStatus.activeEB("insert", e.currentTarget);
}

function appbPD(e){
    nowStatus.activeEB("append", e.currentTarget);
}

function appsPD(e){
    nowStatus.activeEB("append", e.currentTarget);
}

function apptPD(e){
    nowStatus.activeEB("append", e.currentTarget);
}

function reload(e){
    setSsuekSsuek(txt);
}

function canvPD(e){
    nowStatus.drawActive = true;
    e.currentTarget.addEventListener("pointerup", canvCancel);
    e.currentTarget.addEventListener("pointerout", canvCancel);
    
    e.currentTarget.addEventListener("pointermove", canvPM);

    nowStatus.nowCanv = e.currentTarget;
    nowStatus.ctx = e.currentTarget.getContext("2d");

    if (this.setLastTime != undefined){
        clearTimeout(this.setLastTime);
    }
    this.setLastTime = undefined;

    e.currentTarget.removeEventListener("pointerdown", canvPD);
}

function canvCancel(e){
    nowStatus.drawActive = false;
    e.currentTarget.addEventListener("pointerdown", canvPD);

    nowStatus.ctx = undefined;
    nowStatus.lastPointX = -1;
    nowStatus.lastPointY = -1;

    e.currentTarget.removeEventListener("pointermove", canvPM);

    e.currentTarget.removeEventListener("pointerup", canvCancel);
    e.currentTarget.removeEventListener("pointerout", canvCancel);
}

function canvPM(e){
    if (nowStatus.drawActive == false) {return;}
    nowStatus.ctx.lineWidth = 2; nowStatus.ctx.lineCap = "round"; 
    nowStatus.ctx.strokeStyle = "rgba(0,0,0,"+String(e.pressure.toFixed(1))+")";
    nowStatus.ctx.beginPath();
    nowStatus.ctx.moveTo(nowStatus.lastPointX, nowStatus.lastPointY);
    if (nowStatus.lastPointX == -1){
        nowStatus.ctx.moveTo(e.offsetX, e.offsetY);
    }
    nowStatus.ctx.lineTo(e.offsetX, e.offsetY);
    nowStatus.ctx.stroke();

    nowStatus.lastPointX = e.offsetX; nowStatus.lastPointY = e.offsetY; 
    if (this.setLastTime != undefined){
        clearTimeout(this.setLastTime);
    }
    
    this.setLastTime = setTimeout(processOCR, 2000);
}

function processOCR(){
    txtimg = nowStatus.nowCanv.toDataURL();
    console.log(txtimg);
}

document.addEventListener("DOMContentLoaded", () => {
    setSsuekSsuek(txt);
});

    </script>
</body>
</html>